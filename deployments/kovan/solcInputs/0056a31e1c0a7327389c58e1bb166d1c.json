{
"language": "Solidity",
  "sources": {
    "contracts/base/BaseExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"../interfaces/IERC1271.sol\";\nimport \"../interfaces/IBaseExchange.sol\";\nimport \"../interfaces/ITokenFactory.sol\";\nimport \"../interfaces/IStrategy.sol\";\nimport \"../interfaces/IDividendPayingERC20.sol\";\nimport \"../libraries/Orders.sol\";\nimport \"./ReentrancyGuardInitializable.sol\";\n\nabstract contract BaseExchange is ReentrancyGuardInitializable, IBaseExchange {\n    using SafeERC20 for IERC20;\n    using Orders for Orders.Ask;\n    using Orders for Orders.Bid;\n\n    struct BestBid {\n        address bidder;\n        uint256 amount;\n        uint256 price;\n        address recipient;\n        address referrer;\n        uint256 blockNumber;\n    }\n\n    mapping(bytes32 => BestBid) public override bestBid;\n    mapping(bytes32 => bool) public override isCancelled;\n    mapping(bytes32 => uint256) public override amountFilled;\n\n    function __BaseNFTExchange_init() internal initializer {\n        __ReentrancyGuard_init();\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual override returns (bytes32);\n\n    function factory() public view virtual override returns (address);\n\n    function royaltyFeeInfo() public view virtual override returns (address, uint8) {\n        return (address(0), uint8(0));\n    }\n\n    function canTrade(address token) public view virtual override returns (bool) {\n        return token == address(this);\n    }\n\n    function _transfer(\n        address token,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount\n    ) internal virtual;\n\n    function cancel(Orders.Ask memory order) external override {\n        require(order.signer == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        bytes32 hash = order.hash();\n        require(bestBid[hash].bidder == address(0), \"SHOYU: BID_EXISTS\");\n\n        isCancelled[hash] = true;\n\n        emit Cancel(hash);\n    }\n\n    function bid(Orders.Ask memory askOrder, Orders.Bid memory bidOrder)\n        external\n        override\n        nonReentrant\n        returns (bool executed)\n    {\n        bytes32 askHash = askOrder.hash();\n        require(askHash == bidOrder.askHash, \"SHOYU: UNMATCHED_HASH\");\n        require(bidOrder.signer != address(0), \"SHOYU: INVALID_SIGNER\");\n\n        _verify(bidOrder.hash(), bidOrder.signer, bidOrder.v, bidOrder.r, bidOrder.s);\n\n        return\n            _bid(\n                askOrder,\n                askHash,\n                bidOrder.signer,\n                bidOrder.amount,\n                bidOrder.price,\n                bidOrder.recipient,\n                bidOrder.referrer\n            );\n    }\n\n    function bid(\n        Orders.Ask memory askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external override nonReentrant returns (bool executed) {\n        return _bid(askOrder, askOrder.hash(), msg.sender, bidAmount, bidPrice, bidRecipient, bidReferrer);\n    }\n\n    function _bid(\n        Orders.Ask memory askOrder,\n        bytes32 askHash,\n        address bidder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) internal returns (bool executed) {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n        require(bidAmount > 0, \"SHOYU: INVALID_AMOUNT\");\n        uint256 _amountFilled = amountFilled[askHash];\n        require(_amountFilled + bidAmount <= askOrder.amount, \"SHOYU: SOLD_OUT\");\n\n        _validate(askOrder, askHash);\n        _verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s);\n\n        if (IStrategy(askOrder.strategy).canExecute(askOrder.deadline, askOrder.params, bidder, bidPrice)) {\n            amountFilled[askHash] = _amountFilled + bidAmount;\n\n            address recipient = askOrder.recipient;\n            if (recipient == address(0)) recipient = askOrder.signer;\n            require(\n                _transferFeesAndFunds(askOrder.currency, bidder, recipient, bidPrice * bidAmount),\n                \"SHOYU: FAILED_TO_TRANSFER_FUNDS\"\n            );\n\n            if (bidRecipient == address(0)) bidRecipient = bidder;\n            _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, bidAmount);\n\n            emit Execute(askHash, bidder, bidAmount, bidPrice, bidRecipient, bidReferrer);\n            return true;\n        } else {\n            BestBid storage best = bestBid[askHash];\n            if (\n                IStrategy(askOrder.strategy).canBid(\n                    askOrder.deadline,\n                    askOrder.params,\n                    bidder,\n                    bidPrice,\n                    best.price,\n                    best.blockNumber\n                )\n            ) {\n                best.bidder = bidder;\n                best.amount = bidAmount;\n                best.price = bidPrice;\n                best.recipient = bidRecipient;\n                best.referrer = bidReferrer;\n                best.blockNumber = block.number;\n\n                emit Bid(askHash, bidder, bidAmount, bidPrice, bidRecipient, bidReferrer);\n                return false;\n            }\n        }\n        revert(\"SHOYU: FAILURE\");\n    }\n\n    function claim(Orders.Ask memory askOrder) external override nonReentrant {\n        require(canTrade(askOrder.token), \"SHOYU: INVALID_EXCHANGE\");\n\n        bytes32 askHash = askOrder.hash();\n        _validate(askOrder, askHash);\n        _verify(askHash, askOrder.signer, askOrder.v, askOrder.r, askOrder.s);\n\n        BestBid memory best = bestBid[askHash];\n        require(\n            IStrategy(askOrder.strategy).canExecute(askOrder.deadline, askOrder.params, best.bidder, best.price),\n            \"SHOYU: FAILURE\"\n        );\n\n        address recipient = askOrder.recipient;\n        if (recipient == address(0)) recipient = askOrder.signer;\n\n        if (_transferFeesAndFunds(askOrder.currency, best.bidder, recipient, best.price * best.amount)) {\n            amountFilled[askHash] = amountFilled[askHash] + best.amount;\n\n            address bidRecipient = best.recipient;\n            if (bidRecipient == address(0)) bidRecipient = best.bidder;\n            _transfer(askOrder.token, askOrder.signer, bidRecipient, askOrder.tokenId, best.amount);\n\n            delete bestBid[askHash];\n\n            emit Execute(askHash, best.bidder, best.amount, best.price, bidRecipient, best.referrer);\n        } else {\n            isCancelled[askHash] = true;\n\n            emit Cancel(askHash);\n        }\n    }\n\n    function _validate(Orders.Ask memory askOrder, bytes32 askHash) internal view {\n        require(!isCancelled[askHash], \"SHOYU: CANCELLED\");\n\n        require(askOrder.signer != address(0), \"SHOYU: INVALID_MAKER\");\n        require(askOrder.token != address(0), \"SHOYU: INVALID_NFT\");\n        require(askOrder.amount > 0, \"SHOYU: INVALID_AMOUNT\");\n        require(askOrder.strategy != address(0), \"SHOYU: INVALID_STRATEGY\");\n        require(askOrder.currency != address(0), \"SHOYU: INVALID_CURRENCY\");\n        require(ITokenFactory(factory()).isStrategyWhitelisted(askOrder.strategy), \"SHOYU: STRATEGY_NOT_WHITELISTED\");\n    }\n\n    function _verify(\n        bytes32 hash,\n        address signer,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal view {\n        bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), hash));\n        if (Address.isContract(signer)) {\n            require(\n                IERC1271(signer).isValidSignature(digest, abi.encodePacked(r, s, v)) == 0x1626ba7e,\n                \"SHOYU: UNAUTHORIZED\"\n            );\n        } else {\n            require(ecrecover(digest, v, r, s) == signer, \"SHOYU: UNAUTHORIZED\");\n        }\n    }\n\n    function _transferFeesAndFunds(\n        address currency,\n        address from,\n        address to,\n        uint256 amount\n    ) internal returns (bool) {\n        if (!_safeTransferFrom(currency, from, address(this), amount)) {\n            return false;\n        }\n\n        address _factory = factory();\n        uint256 remainder = amount;\n        {\n            (address protocolFeeRecipient, uint8 protocolFeePermil) = ITokenFactory(_factory).protocolFeeInfo();\n            uint256 protocolFeeAmount = (amount * protocolFeePermil) / 1000;\n            IERC20(currency).safeTransfer(protocolFeeRecipient, protocolFeeAmount);\n            remainder -= protocolFeeAmount;\n        }\n\n        {\n            (address operationalFeeRecipient, uint8 operationalFeePermil) =\n                ITokenFactory(_factory).operationalFeeInfo();\n            uint256 operationalFeeAmount = (amount * operationalFeePermil) / 1000;\n            IERC20(currency).safeTransfer(operationalFeeRecipient, operationalFeeAmount);\n            remainder -= operationalFeeAmount;\n        }\n\n        (address royaltyFeeRecipient, uint8 royaltyFeePermil) = royaltyFeeInfo();\n        if (royaltyFeePermil != type(uint8).max) {\n            uint256 royaltyFeeAmount = (remainder * royaltyFeePermil) / 1000;\n            if (royaltyFeeAmount > 0) {\n                remainder -= royaltyFeeAmount;\n                _transferRoyaltyFee(currency, royaltyFeeRecipient, royaltyFeeAmount);\n            }\n        }\n\n        IERC20(currency).safeTransfer(to, remainder);\n        return true;\n    }\n\n    function _safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) private returns (bool) {\n        (bool success, bytes memory returndata) =\n            token.call(abi.encodeWithSelector(IERC20(token).transferFrom.selector, from, to, value));\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool)));\n    }\n\n    function _transferRoyaltyFee(\n        address currency,\n        address to,\n        uint256 amount\n    ) internal {\n        IERC20(currency).safeTransfer(to, amount);\n        if (Address.isContract(to)) {\n            try IDividendPayingERC20(to).sync() returns (uint256) {} catch {}\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\n/// @title Interface for verifying contract-based account signatures\n/// @notice Interface that verifies provided signature for the data\n/// @dev Interface defined by EIP-1271\ninterface IERC1271 {\n    /// @notice Returns whether the provided signature is valid for the provided data\n    /// @dev MUST return the bytes4 magic value 0x1626ba7e when function passes.\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5).\n    /// MUST allow external calls.\n    /// @param hash Hash of the data to be signed\n    /// @param signature Signature byte array associated with _data\n    /// @return magicValue The bytes4 magic value 0x1626ba7e\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "contracts/interfaces/IBaseExchange.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"../libraries/Orders.sol\";\n\ninterface IBaseExchange {\n    event Cancel(bytes32 indexed hash);\n    event Execute(\n        bytes32 indexed hash,\n        address bidder,\n        uint256 amount,\n        uint256 price,\n        address recipient,\n        address referrer\n    );\n    event Bid(bytes32 indexed hash, address bidder, uint256 amount, uint256 price, address recipient, address referrer);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function factory() external view returns (address);\n\n    function royaltyFeeInfo() external view returns (address recipient, uint8 permil);\n\n    function canTrade(address token) external view returns (bool);\n\n    function bestBid(bytes32 hash)\n        external\n        view\n        returns (\n            address bidder,\n            uint256 amount,\n            uint256 price,\n            address recipient,\n            address referrer,\n            uint256 blockNumber\n        );\n\n    function isCancelled(bytes32 hash) external view returns (bool);\n\n    function amountFilled(bytes32 hash) external view returns (uint256);\n\n    function cancel(Orders.Ask memory order) external;\n\n    function bid(Orders.Ask memory askOrder, Orders.Bid memory bidOrder) external returns (bool executed);\n\n    function bid(\n        Orders.Ask memory askOrder,\n        uint256 bidAmount,\n        uint256 bidPrice,\n        address bidRecipient,\n        address bidReferrer\n    ) external returns (bool executed);\n\n    function claim(Orders.Ask memory order) external;\n}\n"
    },
    "contracts/interfaces/ITokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ITokenFactory {\n    event UpgradeNFT721(address newTarget);\n    event UpgradeNFT1155(address newTarget);\n    event UpgradeSocialToken(address newTarget);\n    event UpgradeERC721Exchange(address exchange);\n    event UpgradeERC1155Exchange(address exchange);\n    event DeployNFT721(\n        address indexed proxy,\n        address indexed owner,\n        string name,\n        string symbol,\n        uint256[] tokenIds,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    );\n    event DeployNFT721(\n        address indexed proxy,\n        address indexed owner,\n        string name,\n        string symbol,\n        uint256 toTokenId,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    );\n    event DeployNFT1155(\n        address indexed proxy,\n        address indexed owner,\n        uint256[] tokenIds,\n        uint256[] amounts,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    );\n    event DeploySocialToken(\n        address indexed proxy,\n        address indexed owner,\n        string name,\n        string symbol,\n        address indexed dividendToken\n    );\n    event Tag(address indexed nft, uint256 indexed tokenId, string indexed tag, uint256 tagNonce);\n\n    function MAX_ROYALTY_FEE() external view returns (uint8);\n\n    function MAX_OPERATIONAL_FEE() external view returns (uint8);\n\n    function baseURI721() external view returns (string memory);\n\n    function baseURI1155() external view returns (string memory);\n\n    function erc721Exchange() external view returns (address);\n\n    function erc1155Exchange() external view returns (address);\n\n    function protocolFeeInfo() external view returns (address recipient, uint8 permil);\n\n    function operationalFeeInfo() external view returns (address recipient, uint8 permil);\n\n    function isStrategyWhitelisted(address strategy) external view returns (bool);\n\n    function isDeployerWhitelisted(address strategy) external view returns (bool);\n\n    function setBaseURI721(string memory uri) external;\n\n    function setBaseURI1155(string memory uri) external;\n\n    function setProtocolFeeRecipient(address protocolFeeRecipient) external;\n\n    function setOperationalFeeRecipient(address operationalFeeRecipient) external;\n\n    function setOperationalFee(uint8 operationalFee) external;\n\n    function setDeployerWhitelisted(address deployer, bool whitelisted) external;\n\n    function setStrategyWhitelisted(address strategy, bool whitelisted) external;\n\n    function upgradeNFT721(address newTarget) external;\n\n    function upgradeNFT1155(address newTarget) external;\n\n    function upgradeSocialToken(address newTarget) external;\n\n    function upgradeERC721Exchange(address exchange) external;\n\n    function upgradeERC1155Exchange(address exchange) external;\n\n    function deployNFT721(\n        address owner,\n        string calldata name,\n        string calldata symbol,\n        uint256[] calldata tokenIds,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external returns (address nft);\n\n    function deployNFT721(\n        address owner,\n        string calldata name,\n        string calldata symbol,\n        uint256 toTokenId,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external returns (address nft);\n\n    function isNFT721(address query) external view returns (bool result);\n\n    function deployNFT1155(\n        address owner,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external returns (address nft);\n\n    function isNFT1155(address query) external view returns (bool result);\n\n    function deploySocialToken(\n        address owner,\n        string memory name,\n        string memory symbol,\n        address dividendToken\n    ) external returns (address proxy);\n\n    function isSocialToken(address query) external view returns (bool result);\n\n    function mintWithTags721(\n        address nft,\n        address to,\n        uint256 tokenId,\n        bytes calldata data,\n        string[] calldata tags\n    ) external;\n\n    function mintWithTags1155(\n        address nft,\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        bytes calldata data,\n        string[] calldata tags\n    ) external;\n\n    function setTags721(\n        address nft,\n        uint256 tokenId,\n        string[] calldata tags\n    ) external;\n\n    function setTags1155(\n        address nft,\n        uint256 tokenId,\n        string[] calldata tags\n    ) external;\n}\n"
    },
    "contracts/interfaces/IStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"../libraries/Orders.sol\";\n\ninterface IStrategy {\n    function canExecute(\n        uint256 deadline,\n        bytes memory params,\n        address bidder,\n        uint256 bidPrice\n    ) external view returns (bool);\n\n    function canBid(\n        uint256 deadline,\n        bytes memory params,\n        address bidder,\n        uint256 bidPrice,\n        uint256 bestBidPrice,\n        uint256 bestBidBlock\n    ) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IDividendPayingERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IDividendPayingERC20 is IERC20, IERC20Metadata {\n    /// @dev This event MUST emit when erc20/ether dividend is synced.\n    /// @param increased The amount of increased erc20/ether in wei.\n    event Sync(uint256 increased);\n\n    /// @dev This event MUST emit when an address withdraws their dividend.\n    /// @param to The address which withdraws erc20/ether from this contract.\n    /// @param amount The amount of withdrawn erc20/ether in wei.\n    event DividendWithdrawn(address indexed to, uint256 amount);\n\n    function MAGNITUDE() external view returns (uint256);\n\n    function dividendToken() external view returns (address);\n\n    function totalDividend() external view returns (uint256);\n\n    function sync() external payable returns (uint256 increased);\n\n    function withdrawDividend() external;\n\n    /// @notice View the amount of dividend in wei that an address can withdraw.\n    /// @param account The address of a token holder.\n    /// @return The amount of dividend in wei that `account` can withdraw.\n    function dividendOf(address account) external view returns (uint256);\n\n    /// @notice View the amount of dividend in wei that an address can withdraw.\n    /// @param account The address of a token holder.\n    /// @return The amount of dividend in wei that `account` can withdraw.\n    function withdrawableDividendOf(address account) external view returns (uint256);\n\n    /// @notice View the amount of dividend in wei that an address has withdrawn.\n    /// @param account The address of a token holder.\n    /// @return The amount of dividend in wei that `account` has withdrawn.\n    function withdrawnDividendOf(address account) external view returns (uint256);\n\n    /// @notice View the amount of dividend in wei that an address has earned in total.\n    /// @dev accumulativeDividendOf(account) = withdrawableDividendOf(account) + withdrawnDividendOf(account)\n    /// = (magnifiedDividendPerShare * balanceOf(account) + magnifiedDividendCorrections[account]) / magnitude\n    /// @param account The address of a token holder.\n    /// @return The amount of dividend in wei that `account` has earned in total.\n    function accumulativeDividendOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/libraries/Orders.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nlibrary Orders {\n    // keccak256(\"Ask(address signer,address token,uint256 tokenId,uint256 amount,address strategy,address currency,address recipient,uint256 deadline,bytes params)\")\n    bytes32 internal constant ASK_TYPEHASH = 0x17fdf8831f8bd77353b30f42ba9bc64e7144545a42a890389f298feeb45dec88;\n    // keccak256(\"Bid(bytes32 askHash,address signer,uint256 amount,uint256 price,address recipient,address referrer)\")\n    bytes32 internal constant BID_TYPEHASH = 0xb98e1dc48988064e6dfb813618609d7da80a8841e5f277039788ac4b50d497b2;\n\n    struct Ask {\n        address signer;\n        address token;\n        uint256 tokenId;\n        uint256 amount;\n        address strategy;\n        address currency;\n        address recipient;\n        uint256 deadline;\n        bytes params;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    struct Bid {\n        bytes32 askHash;\n        address signer;\n        uint256 amount;\n        uint256 price;\n        address recipient;\n        address referrer;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    function hash(Ask memory ask) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    ASK_TYPEHASH,\n                    ask.signer,\n                    ask.token,\n                    ask.tokenId,\n                    ask.amount,\n                    ask.strategy,\n                    ask.currency,\n                    ask.recipient,\n                    ask.deadline,\n                    keccak256(ask.params)\n                )\n            );\n    }\n\n    function hash(Bid memory bid) internal pure returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(BID_TYPEHASH, bid.askHash, bid.signer, bid.amount, bid.price, bid.recipient, bid.referrer)\n            );\n    }\n}\n"
    },
    "contracts/base/ReentrancyGuardInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardInitializable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal initializer {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal initializer {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"SHOYU: REENTRANT\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n// solhint-disable-next-line compiler-version\npragma solidity ^0.8.0;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n */\nabstract contract Initializable {\n\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n}\n"
    },
    "contracts/SocialTokenV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./base/DividendPayingERC20.sol\";\nimport \"./base/BaseExchange.sol\";\nimport \"./base/OwnableInitializable.sol\";\nimport \"./interfaces/ISocialToken.sol\";\n\ncontract SocialTokenV0 is DividendPayingERC20, BaseExchange, OwnableInitializable, ISocialToken {\n    bytes32 internal _DOMAIN_SEPARATOR;\n    address internal _factory;\n\n    function initialize(\n        address _owner,\n        string memory _name,\n        string memory _symbol,\n        address _dividendToken\n    ) external override initializer {\n        __Ownable_init(_owner);\n        __DividendPayingERC20_init(_name, _symbol, _dividendToken);\n        _factory = msg.sender;\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        _DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                bytes(_name),\n                0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, // keccak256(bytes(\"1\"))\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function DOMAIN_SEPARATOR() public view override(BaseExchange, IBaseExchange) returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    function factory() public view override(BaseExchange, IBaseExchange) returns (address) {\n        return _factory;\n    }\n\n    function _transfer(\n        address,\n        address from,\n        address to,\n        uint256,\n        uint256 amount\n    ) internal override {\n        _transfer(from, to, amount);\n    }\n\n    function mint(address account, uint256 value) external override onlyOwner {\n        _mint(account, value);\n    }\n\n    function burn(\n        uint256 value,\n        uint256 label,\n        bytes32 data\n    ) external override {\n        _burn(msg.sender, value);\n\n        emit Burn(value, label, data);\n    }\n}\n"
    },
    "contracts/base/DividendPayingERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"./ERC20Initializable.sol\";\nimport \"../libraries/TokenHelper.sol\";\nimport \"../interfaces/IDividendPayingERC20.sol\";\n\n/// @dev A mintable ERC20 token that allows anyone to pay and distribute ether/erc20\n///  to token holders as dividends and allows token holders to withdraw their dividends.\n///  Reference: https://github.com/Roger-Wu/erc1726-dividend-paying-token/blob/master/contracts/DividendPayingToken.sol\nabstract contract DividendPayingERC20 is ERC20Initializable, IDividendPayingERC20 {\n    using SafeCast for uint256;\n    using SafeCast for int256;\n    using TokenHelper for address;\n\n    // For more discussion about choosing the value of `magnitude`,\n    //  see https://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728\n    uint256 public constant override MAGNITUDE = 2**128;\n\n    address public override dividendToken;\n    uint256 public override totalDividend;\n\n    uint256 internal magnifiedDividendPerShare;\n\n    function __DividendPayingERC20_init(\n        string memory _name,\n        string memory _symbol,\n        address _dividendToken\n    ) internal initializer {\n        __ERC20_init(_name, _symbol);\n        dividendToken = _dividendToken;\n    }\n\n    // About dividendCorrection:\n    // If the token balance of a `_user` is never changed, the dividend of `_user` can be computed with:\n    //   `dividendOf(_user) = dividendPerShare * balanceOf(_user)`.\n    // When `balanceOf(_user)` is changed (via minting/burning/transferring tokens),\n    //   `dividendOf(_user)` should not be changed,\n    //   but the computed value of `dividendPerShare * balanceOf(_user)` is changed.\n    // To keep the `dividendOf(_user)` unchanged, we add a correction term:\n    //   `dividendOf(_user) = dividendPerShare * balanceOf(_user) + dividendCorrectionOf(_user)`,\n    //   where `dividendCorrectionOf(_user)` is updated whenever `balanceOf(_user)` is changed:\n    //   `dividendCorrectionOf(_user) = dividendPerShare * (old balanceOf(_user)) - (new balanceOf(_user))`.\n    // So now `dividendOf(_user)` returns the same value before and after `balanceOf(_user)` is changed.\n    mapping(address => int256) internal magnifiedDividendCorrections;\n    mapping(address => uint256) internal withdrawnDividends;\n\n    /// @dev Syncs dividends whenever ether is paid to this contract.\n    receive() external payable {\n        if (msg.value > 0) {\n            require(dividendToken == TokenHelper.ETH, \"SHOYU: UNABLE_TO_RECEIVE_ETH\");\n            sync();\n        }\n    }\n\n    /// @notice Syncs the amount of ether/erc20 increased to token holders as dividends.\n    /// @dev It reverts if the total supply of tokens is 0.\n    /// @return increased The amount of total dividend increased\n    /// It emits the `Sync` event if the amount of received ether/erc20 is greater than 0.\n    /// About undistributed ether/erc20:\n    ///   In each distribution, there is a small amount of ether/erc20 not distributed,\n    ///     the magnified amount of which is\n    ///     `(msg.value * magnitude) % totalSupply()`.\n    ///   With a well-chosen `magnitude`, the amount of undistributed ether/erc20\n    ///     (de-magnified) in a distribution can be less than 1 wei.\n    ///   We can actually keep track of the undistributed ether/erc20 in a distribution\n    ///     and try to distribute it in the next distribution,\n    ///     but keeping track of such data on-chain costs much more than\n    ///     the saved ether/erc20, so we don't do that.\n    function sync() public payable override returns (uint256 increased) {\n        uint256 _totalSupply = totalSupply();\n        require(_totalSupply > 0, \"SHOYU: NO_SUPPLY\");\n\n        uint256 balance = dividendToken.balanceOf(address(this));\n        increased = balance - totalDividend;\n        require(increased > 0, \"SHOYU: INSUFFICIENT_AMOUNT\");\n\n        magnifiedDividendPerShare += (increased * MAGNITUDE) / _totalSupply;\n        totalDividend = balance;\n\n        emit Sync(increased);\n    }\n\n    /// @notice Withdraws the ether/erc20 distributed to the sender.\n    /// @dev It emits a `DividendWithdrawn` event if the amount of withdrawn ether/erc20 is greater than 0.\n    function withdrawDividend() public override {\n        uint256 _withdrawableDividend = withdrawableDividendOf(msg.sender);\n        if (_withdrawableDividend > 0) {\n            withdrawnDividends[msg.sender] += _withdrawableDividend;\n            emit DividendWithdrawn(msg.sender, _withdrawableDividend);\n            totalDividend -= _withdrawableDividend;\n            dividendToken.safeTransfer(msg.sender, _withdrawableDividend);\n        }\n    }\n\n    /// @notice View the amount of dividend in wei that an address can withdraw.\n    /// @param account The address of a token holder.\n    /// @return The amount of dividend in wei that `account` can withdraw.\n    function dividendOf(address account) public view override returns (uint256) {\n        return withdrawableDividendOf(account);\n    }\n\n    /// @notice View the amount of dividend in wei that an address can withdraw.\n    /// @param account The address of a token holder.\n    /// @return The amount of dividend in wei that `account` can withdraw.\n    function withdrawableDividendOf(address account) public view override returns (uint256) {\n        return accumulativeDividendOf(account) - withdrawnDividends[account];\n    }\n\n    /// @notice View the amount of dividend in wei that an address has withdrawn.\n    /// @param account The address of a token holder.\n    /// @return The amount of dividend in wei that `account` has withdrawn.\n    function withdrawnDividendOf(address account) public view override returns (uint256) {\n        return withdrawnDividends[account];\n    }\n\n    /// @notice View the amount of dividend in wei that an address has earned in total.\n    /// @dev accumulativeDividendOf(account) = withdrawableDividendOf(account) + withdrawnDividendOf(account)\n    /// = (magnifiedDividendPerShare * balanceOf(account) + magnifiedDividendCorrections[account]) / magnitude\n    /// @param account The address of a token holder.\n    /// @return The amount of dividend in wei that `account` has earned in total.\n    function accumulativeDividendOf(address account) public view override returns (uint256) {\n        return\n            ((magnifiedDividendPerShare * balanceOf(account)).toInt256() + magnifiedDividendCorrections[account])\n                .toUint256() / MAGNITUDE;\n    }\n\n    /// @dev Internal function that transfer tokens from one address to another.\n    /// Update magnifiedDividendCorrections to keep dividends unchanged.\n    /// @param from The address to transfer from.\n    /// @param to The address to transfer to.\n    /// @param value The amount to be transferred.\n    function _transfer(\n        address from,\n        address to,\n        uint256 value\n    ) internal override {\n        super._transfer(from, to, value);\n\n        int256 _magCorrection = (magnifiedDividendPerShare * value).toInt256();\n        magnifiedDividendCorrections[from] += _magCorrection;\n        magnifiedDividendCorrections[to] -= _magCorrection;\n    }\n\n    /// @dev Internal function that mints tokens to an account.\n    /// Update magnifiedDividendCorrections to keep dividends unchanged.\n    /// @param account The account that will receive the created tokens.\n    /// @param value The amount that will be created.\n    function _mint(address account, uint256 value) internal override {\n        super._mint(account, value);\n\n        magnifiedDividendCorrections[account] -= (magnifiedDividendPerShare * value).toInt256();\n    }\n\n    /// @dev Internal function that burns an amount of the token of a given account.\n    /// Update magnifiedDividendCorrections to keep dividends unchanged.\n    /// @param account The account whose tokens will be burnt.\n    /// @param value The amount that will be burnt.\n    function _burn(address account, uint256 value) internal override {\n        super._burn(account, value);\n\n        magnifiedDividendCorrections[account] += (magnifiedDividendPerShare * value).toInt256();\n    }\n}\n"
    },
    "contracts/base/OwnableInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\nimport \"../interfaces/IOwnable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableInitializable is Initializable, IOwnable {\n    address private _owner;\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init(address __owner) internal initializer {\n        __Ownable_init_unchained(__owner);\n    }\n\n    function __Ownable_init_unchained(address __owner) internal initializer {\n        _owner = __owner;\n        emit OwnershipTransferred(address(0), __owner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual override returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == msg.sender, \"SHOYU: FORBIDDEN\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual override onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        require(newOwner != address(0), \"SHOYU: INVALID_NEW_OWNER\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/interfaces/ISocialToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./IDividendPayingERC20.sol\";\nimport \"./IBaseExchange.sol\";\nimport \"./IOwnable.sol\";\n\ninterface ISocialToken is IDividendPayingERC20, IBaseExchange, IOwnable {\n    event Burn(uint256 amount, uint256 indexed label, bytes32 data);\n\n    function initialize(\n        address owner,\n        string memory name,\n        string memory symbol,\n        address dividendToken\n    ) external;\n\n    function mint(address account, uint256 value) external;\n\n    function burn(\n        uint256 value,\n        uint256 id,\n        bytes32 data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "contracts/base/ERC20Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Initializable is Initializable, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The defaut value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal initializer {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(currentAllowance >= amount, \"SHOYU: INSUFFICIENT_ALLOWANCE\");\n        _approve(sender, msg.sender, currentAllowance - amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[msg.sender][spender];\n        require(currentAllowance >= subtractedValue, \"SHOYU: ALLOWANCE_UNDERFLOW\");\n        _approve(msg.sender, spender, currentAllowance - subtractedValue);\n\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"SHOYU: INVALID_SENDER\");\n        require(recipient != address(0), \"SHOYU: INVALID_RECIPIENT\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"SHOYU: INSUFFICIENT_BALANCE\");\n        _balances[sender] = senderBalance - amount;\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"SHOYU: INVALID_ACCOUNT\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"SHOYU: INVALID_ACCOUNT\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"SHOYU: INSUFFICIENT_BALANCE\");\n        _balances[account] = accountBalance - amount;\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"SHOYU: INVALID_OWNER\");\n        require(spender != address(0), \"SHOYU: INVALID_SPENDER\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/libraries/TokenHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nlibrary TokenHelper {\n    using SafeERC20 for IERC20;\n\n    address public constant ETH = 0x0000000000000000000000000000000000000000;\n\n    function balanceOf(address token, address account) internal view returns (uint256) {\n        if (token == ETH) {\n            return account.balance;\n        } else {\n            return IERC20(token).balanceOf(account);\n        }\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 amount\n    ) internal {\n        if (token == ETH) {\n            (bool success, ) = to.call{value: amount}(\"\");\n            require(success, \"SHOYU: TRANSFER_FAILURE\");\n        } else {\n            IERC20(token).safeTransfer(to, amount);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface IOwnable {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function owner() external view returns (address);\n\n    function renounceOwnership() external;\n\n    function transferOwnership(address newOwner) external;\n}\n"
    },
    "contracts/interfaces/IBaseNFT721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\n\nimport \"./IOwnable.sol\";\n\ninterface IBaseNFT721 is IERC721, IERC721Metadata, IOwnable {\n    event Burn(uint256 indexed tokenId, uint256 indexed label, bytes32 data);\n\n    event ParkTokenIds(uint256 toTokenId);\n\n    function PERMIT_TYPEHASH() external view returns (bytes32);\n\n    function PERMIT_ALL_TYPEHASH() external view returns (bytes32);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function factory() external view returns (address);\n\n    function nonces(uint256 tokenId) external view returns (uint256);\n\n    function noncesForAll(address account) external view returns (uint256);\n\n    function parked(uint256 tokenId) external view returns (bool);\n\n    function initialize(\n        string calldata name,\n        string calldata symbol,\n        address _owner\n    ) external;\n\n    function setTokenURI(uint256 id, string memory uri) external;\n\n    function setBaseURI(string memory uri) external;\n\n    function parkTokenIds(uint256 toTokenId) external;\n\n    function mint(\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    function mintBatch(\n        address to,\n        uint256[] calldata tokenIds,\n        bytes calldata data\n    ) external;\n\n    function burn(\n        uint256 tokenId,\n        uint256 label,\n        bytes32 data\n    ) external;\n\n    function burnBatch(uint256[] calldata tokenIds) external;\n\n    function permit(\n        address spender,\n        uint256 tokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    function permitAll(\n        address owner,\n        address spender,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n      * @dev Safely transfers `tokenId` token from `from` to `to`.\n      *\n      * Requirements:\n      *\n      * - `from` cannot be the zero address.\n      * - `to` cannot be the zero address.\n      * - `tokenId` token must exist and be owned by `from`.\n      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n      *\n      * Emits a {Transfer} event.\n      */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/TokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport \"./interfaces/ITokenFactory.sol\";\nimport \"./interfaces/IBaseNFT721.sol\";\nimport \"./interfaces/IBaseNFT1155.sol\";\nimport \"./base/ProxyFactory.sol\";\nimport \"./ERC721ExchangeV0.sol\";\nimport \"./ERC1155ExchangeV0.sol\";\n\ncontract TokenFactory is ProxyFactory, Ownable, ITokenFactory {\n    uint8 public constant override MAX_ROYALTY_FEE = 250; // 25%\n    uint8 public constant override MAX_OPERATIONAL_FEE = 50; // 5%\n\n    address[] internal _targets721;\n    address[] internal _targets1155;\n    address[] internal _targetsSocialToken;\n\n    address internal _protocolFeeRecipient;\n    uint8 internal _protocolFee; // out of 1000\n    address internal _operationalFeeRecipient;\n    uint8 internal _operationalFee; // out of 1000\n\n    string public override baseURI721;\n    string public override baseURI1155;\n\n    address public override erc721Exchange;\n    address public override erc1155Exchange;\n    // any account can deploy proxies if isDeployerWhitelisted[0x0000000000000000000000000000000000000000] == true\n    mapping(address => bool) public override isDeployerWhitelisted;\n    mapping(address => bool) public override isStrategyWhitelisted;\n\n    mapping(address => mapping(uint256 => uint256)) public tagNonces;\n\n    modifier onlyDeployer {\n        require(isDeployerWhitelisted[address(0)] || isDeployerWhitelisted[msg.sender], \"SHOYU: FORBIDDEN\");\n        _;\n    }\n\n    constructor(\n        address protocolFeeRecipient,\n        uint8 protocolFee,\n        address operationalFeeRecipient,\n        uint8 operationalFee,\n        string memory _baseURI721,\n        string memory _baseURI1155\n    ) {\n        _protocolFeeRecipient = protocolFeeRecipient;\n        _protocolFee = protocolFee;\n        _operationalFeeRecipient = operationalFeeRecipient;\n        _operationalFee = operationalFee;\n\n        baseURI721 = _baseURI721;\n        baseURI1155 = _baseURI1155;\n    }\n\n    function protocolFeeInfo() external view override returns (address recipient, uint8 permil) {\n        return (_protocolFeeRecipient, _protocolFee);\n    }\n\n    function operationalFeeInfo() external view override returns (address recipient, uint8 permil) {\n        return (_operationalFeeRecipient, _operationalFee);\n    }\n\n    function setBaseURI721(string memory uri) external override onlyOwner {\n        baseURI721 = uri;\n    }\n\n    function setBaseURI1155(string memory uri) external override onlyOwner {\n        baseURI1155 = uri;\n    }\n\n    // This function should be called by a multi-sig `owner`, not an EOA\n    function setProtocolFeeRecipient(address protocolFeeRecipient) external override onlyOwner {\n        require(protocolFeeRecipient != address(0), \"SHOYU: INVALID_FEE_RECIPIENT\");\n\n        _protocolFeeRecipient = protocolFeeRecipient;\n    }\n\n    // This function should be called by a multi-sig `owner`, not an EOA\n    function setOperationalFeeRecipient(address operationalFeeRecipient) external override onlyOwner {\n        require(operationalFeeRecipient != address(0), \"SHOYU: INVALID_RECIPIENT\");\n\n        _operationalFeeRecipient = operationalFeeRecipient;\n    }\n\n    // This function should be called by a multi-sig `owner`, not an EOA\n    function setOperationalFee(uint8 operationalFee) external override onlyOwner {\n        require(operationalFee <= MAX_OPERATIONAL_FEE, \"SHOYU: INVALID_FEE\");\n\n        _operationalFee = operationalFee;\n    }\n\n    // This function should be called by a multi-sig `owner`, not an EOA\n    function setDeployerWhitelisted(address deployer, bool whitelisted) external override onlyOwner {\n        require(deployer != address(0), \"SHOYU: INVALID_ADDRESS\");\n\n        isDeployerWhitelisted[deployer] = whitelisted;\n    }\n\n    // This function should be called by a multi-sig `owner`, not an EOA\n    function setStrategyWhitelisted(address strategy, bool whitelisted) external override onlyOwner {\n        require(strategy != address(0), \"SHOYU: INVALID_ADDRESS\");\n\n        isStrategyWhitelisted[strategy] = whitelisted;\n    }\n\n    // This function should be called by a multi-sig `owner`, not an EOA\n    function upgradeNFT721(address newTarget) external override onlyOwner {\n        _targets721.push(newTarget);\n\n        emit UpgradeNFT721(newTarget);\n    }\n\n    // This function should be called by a multi-sig `owner`, not an EOA\n    function upgradeNFT1155(address newTarget) external override onlyOwner {\n        _targets1155.push(newTarget);\n\n        emit UpgradeNFT1155(newTarget);\n    }\n\n    // This function should be called by a multi-sig `owner`, not an EOA\n    function upgradeSocialToken(address newTarget) external override onlyOwner {\n        _targetsSocialToken.push(newTarget);\n\n        emit UpgradeSocialToken(newTarget);\n    }\n\n    // This function should be called by a multi-sig `owner`, not an EOA\n    function upgradeERC721Exchange(address exchange) external override onlyOwner {\n        erc721Exchange = exchange;\n\n        emit UpgradeERC721Exchange(exchange);\n    }\n\n    // This function should be called by a multi-sig `owner`, not an EOA\n    function upgradeERC1155Exchange(address exchange) external override onlyOwner {\n        erc1155Exchange = exchange;\n\n        emit UpgradeERC1155Exchange(exchange);\n    }\n\n    function deployNFT721(\n        address owner,\n        string calldata name,\n        string calldata symbol,\n        uint256[] memory tokenIds,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external override onlyDeployer returns (address nft) {\n        require(bytes(name).length > 0, \"SHOYU: INVALID_NAME\");\n        require(bytes(symbol).length > 0, \"SHOYU: INVALID_SYMBOL\");\n\n        nft = _createProxy(\n            _targets721[_targets721.length - 1],\n            abi.encodeWithSignature(\n                \"initialize(address,string,string,uint256[],address,uint8)\",\n                owner,\n                name,\n                symbol,\n                tokenIds,\n                royaltyFeeRecipient,\n                royaltyFee\n            )\n        );\n\n        emit DeployNFT721(nft, owner, name, symbol, tokenIds, royaltyFeeRecipient, royaltyFee);\n    }\n\n    function deployNFT721(\n        address owner,\n        string calldata name,\n        string calldata symbol,\n        uint256 toTokenId,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external override onlyDeployer returns (address nft) {\n        require(bytes(name).length > 0, \"SHOYU: INVALID_NAME\");\n        require(bytes(symbol).length > 0, \"SHOYU: INVALID_SYMBOL\");\n\n        nft = _createProxy(\n            _targets721[_targets721.length - 1],\n            abi.encodeWithSignature(\n                \"initialize(address,string,string,uint256,address,uint8)\",\n                owner,\n                name,\n                symbol,\n                toTokenId,\n                royaltyFeeRecipient,\n                royaltyFee\n            )\n        );\n\n        emit DeployNFT721(nft, owner, name, symbol, toTokenId, royaltyFeeRecipient, royaltyFee);\n    }\n\n    function isNFT721(address query) external view override returns (bool result) {\n        for (uint256 i = _targets721.length - 1; i >= 0; i--) {\n            if (_isProxy(_targets721[i], query)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function deployNFT1155(\n        address owner,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external override onlyDeployer returns (address nft) {\n        nft = _createProxy(\n            _targets1155[_targets1155.length - 1],\n            abi.encodeWithSignature(\n                \"initialize(address,uint256[],uint256[],address,uint8)\",\n                owner,\n                tokenIds,\n                amounts,\n                royaltyFeeRecipient,\n                royaltyFee\n            )\n        );\n\n        emit DeployNFT1155(nft, owner, tokenIds, amounts, royaltyFeeRecipient, royaltyFee);\n    }\n\n    function isNFT1155(address query) external view override returns (bool result) {\n        for (uint256 i = _targets1155.length - 1; i >= 0; i--) {\n            if (_isProxy(_targets1155[i], query)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function deploySocialToken(\n        address owner,\n        string memory name,\n        string memory symbol,\n        address dividendToken\n    ) external override onlyDeployer returns (address proxy) {\n        bytes memory initData =\n            abi.encodeWithSignature(\"initialize(address,string,string,address)\", owner, name, symbol, dividendToken);\n        proxy = _createProxy(_targetsSocialToken[_targetsSocialToken.length - 1], initData);\n\n        emit DeploySocialToken(proxy, owner, name, symbol, dividendToken);\n    }\n\n    function isSocialToken(address query) external view override returns (bool result) {\n        for (uint256 i = _targetsSocialToken.length - 1; i >= 0; i--) {\n            if (_isProxy(_targetsSocialToken[i], query)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function mintWithTags721(\n        address nft,\n        address to,\n        uint256 tokenId,\n        bytes memory data,\n        string[] memory tags\n    ) external override {\n        _setTags(nft, tokenId, tags);\n        IBaseNFT721(nft).mint(to, tokenId, data);\n    }\n\n    function mintWithTags1155(\n        address nft,\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        bytes memory data,\n        string[] memory tags\n    ) external override {\n        _setTags(nft, tokenId, tags);\n        IBaseNFT1155(nft).mint(to, tokenId, amount, data);\n    }\n\n    function setTags721(\n        address nft,\n        uint256 tokenId,\n        string[] memory tags\n    ) external override {\n        require(IBaseNFT721(nft).ownerOf(tokenId) == msg.sender, \"SHOYU: FORBIDDEN\");\n        _setTags(nft, tokenId, tags);\n    }\n\n    function setTags1155(\n        address nft,\n        uint256 tokenId,\n        string[] memory tags\n    ) external override {\n        require(IBaseNFT1155(nft).balanceOf(msg.sender, tokenId) > 0, \"SHOYU: FORBIDDEN\");\n        _setTags(nft, tokenId, tags);\n    }\n\n    function _setTags(\n        address nft,\n        uint256 tokenId,\n        string[] memory tags\n    ) internal {\n        uint256 nonce = tagNonces[nft][tokenId]++;\n\n        for (uint256 i; i < tags.length; i++) {\n            emit Tag(nft, tokenId, tags[i], nonce);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/interfaces/IBaseNFT1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\n\nimport \"./IOwnable.sol\";\n\ninterface IBaseNFT1155 is IERC1155, IERC1155MetadataURI, IOwnable {\n    event Burn(uint256 tokenId, uint256 amount, uint256 indexed label, bytes32 data);\n\n    function PERMIT_TYPEHASH() external view returns (bytes32);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function factory() external view returns (address);\n\n    function nonces(address account) external view returns (uint256);\n\n    function initialize(address _owner) external;\n\n    function setURI(uint256 id, string memory uri) external;\n\n    function setBaseURI(string memory baseURI) external;\n\n    function mint(\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    function mintBatch(\n        address to,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n\n    function burn(\n        uint256 tokenId,\n        uint256 amount,\n        uint256 label,\n        bytes32 data\n    ) external;\n\n    function burnBatch(uint256[] calldata tokenIds, uint256[] calldata amounts) external;\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/base/ProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\n// Reference: https://github.com/optionality/clone-factory/blob/master/contracts/CloneFactory.sol\ncontract ProxyFactory {\n    function _createProxy(address target, bytes memory initData) internal returns (address proxy) {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            proxy := create(0, clone, 0x37)\n        }\n\n        if (initData.length > 0) {\n            (bool success, ) = proxy.call(initData);\n            require(success, \"SHOYU: CALL_FAILURE\");\n        }\n    }\n\n    function _isProxy(address target, address query) internal view returns (bool result) {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x363d3d373d3d3d363d7300000000000000000000000000000000000000000000)\n            mstore(add(clone, 0xa), targetBytes)\n            mstore(add(clone, 0x1e), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n\n            let other := add(clone, 0x40)\n            extcodecopy(query, other, 0, 0x2d)\n            result := and(eq(mload(clone), mload(other)), eq(mload(add(clone, 0xd)), mload(add(other, 0xd))))\n        }\n    }\n}\n"
    },
    "contracts/ERC721ExchangeV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport \"./base/BaseExchange.sol\";\n\ncontract ERC721ExchangeV0 is BaseExchange {\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    address internal immutable _factory;\n\n    constructor(address factory_) {\n        __BaseNFTExchange_init();\n        _factory = factory_;\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        _DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(\"ERC721Exchange\"),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    function factory() public view override returns (address) {\n        return _factory;\n    }\n\n    function canTrade(address nft) public view override returns (bool) {\n        return !ITokenFactory(_factory).isNFT721(nft);\n    }\n\n    function _transfer(\n        address nft,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256\n    ) internal override {\n        IERC721(nft).safeTransferFrom(from, to, tokenId);\n    }\n}\n"
    },
    "contracts/ERC1155ExchangeV0.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n\nimport \"./base/BaseExchange.sol\";\n\ncontract ERC1155ExchangeV0 is BaseExchange {\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\n    address internal immutable _factory;\n\n    constructor(address factory_) {\n        __BaseNFTExchange_init();\n        _factory = factory_;\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        _DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(\"ERC1155Exchange\"),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    function factory() public view override returns (address) {\n        return _factory;\n    }\n\n    function canTrade(address nft) public view override returns (bool) {\n        return !ITokenFactory(_factory).isNFT1155(nft);\n    }\n\n    function _transfer(\n        address nft,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount\n    ) internal override {\n        IERC1155(nft).safeTransferFrom(from, to, tokenId, amount, \"\");\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(address indexed operator, address indexed from, address indexed to, uint256[] ids, uint256[] values);\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "contracts/base/ERC1155Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol\";\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155Initializable is Initializable, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    function __ERC1155_init(string memory uri_) internal initializer {\n        __ERC1155_init_unchained(uri_);\n    }\n\n    function __ERC1155_init_unchained(string memory uri_) internal initializer {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"SHOYU: INVALID_ADDRESS\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"SHOYU: LENGTHS_NOT_EQUAL\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(to != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(from == msg.sender || isApprovedForAll(from, msg.sender), \"SHOYU: FORBIDDEN\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _transfer(from, to, id, amount);\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount\n    ) internal {\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"SHOYU: INSUFFICIENT_BALANCE\");\n        _balances[id][from] = fromBalance - amount;\n        _balances[id][to] += amount;\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(ids.length == amounts.length, \"SHOYU: LENGTHS_NOT_EQUAL\");\n        require(to != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(from == msg.sender || isApprovedForAll(from, msg.sender), \"SHOYU: FORBIDDEN\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"SHOYU: INSUFFICIENT_BALANCE\");\n            _balances[id][from] = fromBalance - amount;\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    function _setApprovalForAll(\n        address account,\n        address operator,\n        bool approved\n    ) internal {\n        require(account != operator, \"SHOYU: NOT_ALLOWED\");\n\n        _operatorApprovals[account][operator] = approved;\n        emit ApprovalForAll(account, operator, approved);\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address account,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(account != address(0), \"SHOYU: INVALID_ADDRESS\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][account] += amount;\n        emit TransferSingle(operator, address(0), account, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(ids.length == amounts.length, \"SHOYU: LENGTHS_NOT_EQUAL\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `account`\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address account,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(account != address(0), \"SHOYU: INVALID_ADDRESS\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 accountBalance = _balances[id][account];\n        require(accountBalance >= amount, \"SHOYU: INSUFFICIENT_BALANCE\");\n        _balances[id][account] = accountBalance - amount;\n\n        emit TransferSingle(operator, account, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address account,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(account != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(ids.length == amounts.length, \"SHOYU: LENGTHS_NOT_EQUAL\");\n\n        address operator = msg.sender;\n\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 accountBalance = _balances[id][account];\n            require(accountBalance >= amount, \"SHOYU: INSUFFICIENT_BALANCE\");\n            _balances[id][account] = accountBalance - amount;\n        }\n\n        emit TransferBatch(operator, account, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver(to).onERC1155Received.selector) {\n                    revert(\"SHOYU: INVALID_RECEIVER\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"SHOYU: NO_RECEIVER\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver(to).onERC1155BatchReceived.selector) {\n                    revert(\"SHOYU: INVALID_RECEIVER\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"SHOYU: NO_RECEIVER\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n\n    /**\n        @dev Handles the receipt of a single ERC1155 token type. This function is\n        called at the end of a `safeTransferFrom` after the balance has been updated.\n        To accept the transfer, this must return\n        `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n        (i.e. 0xf23a6e61, or its own function selector).\n        @param operator The address which initiated the transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param id The ID of the token being transferred\n        @param value The amount of tokens being transferred\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n    */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n\n    /**\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\n        is called at the end of a `safeBatchTransferFrom` after the balances have\n        been updated. To accept the transfer(s), this must return\n        `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n        (i.e. 0xbc197c81, or its own function selector).\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\n        @param from The address which previously owned the token\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\n        @param data Additional data with no specified format\n        @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n    */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    )\n        external\n        returns(bytes4);\n}\n"
    },
    "contracts/base/ERC721Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Initializable is Initializable, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Upper bound of tokenId parked\n    uint256 private _toTokenIdParked;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal initializer {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal initializer {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"SHOYU: INVALID_OWNER\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"SHOYU: INVALID_TOKEN_ID\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden\n     * in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Initializable.ownerOf(tokenId);\n        require(to != owner, \"SHOYU: INVALID_TO\");\n\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender), \"SHOYU: FORBIDDEN\");\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"SHOYU: INVALID_TOKEN_ID\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(msg.sender, operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"SHOYU: FORBIDDEN\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"SHOYU: INVALID_RECEIVER\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"SHOYU: INVALID_TOKEN_ID\");\n        address owner = ERC721Initializable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal {\n        require(operator != owner, \"SHOYU: INVALID_OPERATOR\");\n\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    function _parked(uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Initializable.ownerOf(tokenId);\n        return owner == address(0) && tokenId < _toTokenIdParked;\n    }\n\n    function _parkTokenIds(uint256 toTokenId) internal virtual {\n        uint256 fromTokenId = _toTokenIdParked;\n        require(toTokenId > fromTokenId, \"SHOYU: INVALID_TO_TOKEN_ID\");\n\n        _toTokenIdParked = toTokenId;\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(_checkOnERC721Received(address(0), to, tokenId, _data), \"SHOYU: INVALID_RECEIVER\");\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"SHOYU: INVALID_TO\");\n        require(!_exists(tokenId), \"SHOYU: ALREADY_MINTED\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Initializable.ownerOf(tokenId);\n        require(owner != address(0), \"SHOYU: INVALID_TOKEN_ID\");\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Initializable.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Initializable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver(to).onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"SHOYU: INVALID_RECEIVER\");\n                } else {\n                    // solhint-disable-next-line no-inline-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant alphabet = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = alphabet[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n}\n"
    },
    "contracts/base/BaseNFT721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../interfaces/IBaseNFT721.sol\";\nimport \"../interfaces/IERC1271.sol\";\nimport \"../interfaces/ITokenFactory.sol\";\nimport \"../base/ERC721Initializable.sol\";\nimport \"../base/OwnableInitializable.sol\";\n\nabstract contract BaseNFT721 is ERC721Initializable, OwnableInitializable, IBaseNFT721 {\n    // keccak256(\"Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_TYPEHASH =\n        0x49ecf333e5b8c95c40fdafc95c1ad136e8914a8fb55e9dc8bb01eaa83a2df9ad;\n    // keccak256(\"Permit(address owner,address spender,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_ALL_TYPEHASH =\n        0xdaab21af31ece73a508939fedd476a5ee5129a5ed4bb091f3236ffb45394df62;\n    bytes32 internal _DOMAIN_SEPARATOR;\n\n    address internal _factory;\n    string internal __baseURI;\n    mapping(uint256 => string) internal _uris;\n\n    mapping(uint256 => uint256) public override nonces;\n    mapping(address => uint256) public override noncesForAll;\n\n    function initialize(\n        string memory _name,\n        string memory _symbol,\n        address _owner\n    ) public override initializer {\n        __ERC721_init(_name, _symbol);\n        __Ownable_init(_owner);\n        _factory = msg.sender;\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        _DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                keccak256(bytes(_name)),\n                0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, // keccak256(bytes(\"1\"))\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual override returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    function factory() public view virtual override returns (address) {\n        return _factory;\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721Initializable, IERC721Metadata)\n        returns (string memory)\n    {\n        require(_exists(tokenId) || _parked(tokenId), \"SHOYU: INVALID_TOKEN_ID\");\n\n        string memory _uri = _uris[tokenId];\n        if (bytes(_uri).length > 0) {\n            return _uri;\n        } else {\n            string memory baseURI = __baseURI;\n            if (bytes(baseURI).length > 0) {\n                return string(abi.encodePacked(baseURI, Strings.toString(tokenId), \".json\"));\n            } else {\n                baseURI = ITokenFactory(_factory).baseURI721();\n                string memory addy = Strings.toHexString(uint160(address(this)), 20);\n                return string(abi.encodePacked(baseURI, addy, \"/\", Strings.toString(tokenId), \".json\"));\n            }\n        }\n    }\n\n    function parked(uint256 tokenId) external view override returns (bool) {\n        return _parked(tokenId);\n    }\n\n    function setTokenURI(uint256 id, string memory newURI) external override onlyOwner {\n        _uris[id] = newURI;\n    }\n\n    function setBaseURI(string memory uri) external override onlyOwner {\n        __baseURI = uri;\n    }\n\n    function parkTokenIds(uint256 toTokenId) external override {\n        require(owner() == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _parkTokenIds(toTokenId);\n\n        emit ParkTokenIds(toTokenId);\n    }\n\n    function mint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) external override {\n        require(_factory == msg.sender || owner() == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _safeMint(to, tokenId, data);\n    }\n\n    function mintBatch(\n        address to,\n        uint256[] memory tokenIds,\n        bytes memory data\n    ) external override {\n        require(owner() == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _safeMint(to, tokenIds[i], data);\n        }\n    }\n\n    function burn(\n        uint256 tokenId,\n        uint256 label,\n        bytes32 data\n    ) external override {\n        require(ownerOf(tokenId) == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _burn(tokenId);\n\n        emit Burn(tokenId, label, data);\n    }\n\n    function burnBatch(uint256[] memory tokenIds) external override {\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            uint256 tokenId = tokenIds[i];\n            require(ownerOf(tokenId) == msg.sender, \"SHOYU: FORBIDDEN\");\n\n            _burn(tokenId);\n        }\n    }\n\n    function permit(\n        address spender,\n        uint256 tokenId,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(block.timestamp <= deadline, \"SHOYU: EXPIRED\");\n\n        bytes32 digest =\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    _DOMAIN_SEPARATOR,\n                    keccak256(abi.encode(PERMIT_TYPEHASH, spender, tokenId, nonces[tokenId], deadline))\n                )\n            );\n        nonces[tokenId] += 1;\n\n        address owner = ownerOf(tokenId);\n        require(spender != owner, \"SHOYU: NOT_NECESSARY\");\n\n        if (Address.isContract(owner)) {\n            require(\n                IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) == 0x1626ba7e,\n                \"SHOYU: UNAUTHORIZED\"\n            );\n        } else {\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress != address(0), \"SHOYU: INVALID_SIGNATURE\");\n            require(recoveredAddress == owner, \"SHOYU: UNAUTHORIZED\");\n        }\n\n        _approve(spender, tokenId);\n    }\n\n    function permitAll(\n        address owner,\n        address spender,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(block.timestamp <= deadline, \"SHOYU: EXPIRED\");\n\n        bytes32 digest =\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    _DOMAIN_SEPARATOR,\n                    keccak256(abi.encode(PERMIT_ALL_TYPEHASH, owner, spender, noncesForAll[owner], deadline))\n                )\n            );\n        noncesForAll[owner] += 1;\n\n        if (Address.isContract(owner)) {\n            require(\n                IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) == 0x1626ba7e,\n                \"SHOYU: UNAUTHORIZED\"\n            );\n        } else {\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress != address(0), \"SHOYU: INVALID_SIGNATURE\");\n            require(recoveredAddress == owner, \"SHOYU: UNAUTHORIZED\");\n        }\n\n        _setApprovalForAll(owner, spender, true);\n    }\n}\n"
    },
    "contracts/NFT721V0.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"./interfaces/INFT721.sol\";\nimport \"./interfaces/IERC2981.sol\";\nimport \"./base/BaseNFT721.sol\";\nimport \"./base/BaseExchange.sol\";\n\ncontract NFT721V0 is BaseNFT721, BaseExchange, IERC2981, INFT721 {\n    uint8 internal _MAX_ROYALTY_FEE;\n\n    address internal _royaltyFeeRecipient;\n    uint8 internal _royaltyFee; // out of 1000\n\n    function initialize(\n        address _owner,\n        string memory _name,\n        string memory _symbol,\n        uint256[] memory tokenIds,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external override initializer {\n        __BaseNFTExchange_init();\n        initialize(_name, _symbol, _owner);\n        _MAX_ROYALTY_FEE = ITokenFactory(_factory).MAX_ROYALTY_FEE();\n\n        for (uint256 i = 0; i < tokenIds.length; i++) {\n            _safeMint(_owner, tokenIds[i]);\n        }\n\n        setRoyaltyFeeRecipient(royaltyFeeRecipient);\n        _royaltyFee = type(uint8).max;\n        if (royaltyFee != 0) setRoyaltyFee(royaltyFee);\n    }\n\n    function initialize(\n        address _owner,\n        string memory _name,\n        string memory _symbol,\n        uint256 toTokenId,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external override initializer {\n        __BaseNFTExchange_init();\n        initialize(_name, _symbol, _owner);\n\n        _parkTokenIds(toTokenId);\n\n        emit ParkTokenIds(toTokenId);\n\n        setRoyaltyFeeRecipient(royaltyFeeRecipient);\n        setRoyaltyFee(royaltyFee);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC721Initializable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == 0x2a55205a || super.supportsInterface(interfaceId);\n    }\n\n    function DOMAIN_SEPARATOR() public view override(BaseNFT721, BaseExchange, INFT721) returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    function factory() public view override(BaseNFT721, BaseExchange, INFT721) returns (address) {\n        return _factory;\n    }\n\n    function royaltyFeeInfo() public view override(BaseExchange, INFT721) returns (address recipient, uint8 permil) {\n        return (_royaltyFeeRecipient, _royaltyFee);\n    }\n\n    function royaltyInfo(uint256, uint256 _salePrice) external view override returns (address, uint256) {\n        return (_royaltyFeeRecipient, (_salePrice * _royaltyFee) / 1000);\n    }\n\n    function _transfer(\n        address,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256\n    ) internal override {\n        if (from == owner() && _parked(tokenId)) {\n            _safeMint(to, tokenId);\n        } else {\n            _transfer(from, to, tokenId);\n        }\n    }\n\n    function setRoyaltyFeeRecipient(address royaltyFeeRecipient) public override onlyOwner {\n        require(royaltyFeeRecipient != address(0), \"SHOYU: INVALID_FEE_RECIPIENT\");\n\n        _royaltyFeeRecipient = royaltyFeeRecipient;\n\n        emit SetRoyaltyFeeRecipient(royaltyFeeRecipient);\n    }\n\n    function setRoyaltyFee(uint8 royaltyFee) public override onlyOwner {\n        if (_royaltyFee == type(uint8).max) {\n            require(royaltyFee <= _MAX_ROYALTY_FEE, \"SHOYU: INVALID_FEE\");\n        } else {\n            require(royaltyFee < _royaltyFee, \"SHOYU: INVALID_FEE\");\n        }\n\n        _royaltyFee = royaltyFee;\n\n        emit SetRoyaltyFee(royaltyFee);\n    }\n}\n"
    },
    "contracts/interfaces/INFT721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./IBaseNFT721.sol\";\nimport \"./IBaseExchange.sol\";\n\ninterface INFT721 is IBaseNFT721, IBaseExchange {\n    event SetRoyaltyFeeRecipient(address recipient);\n    event SetRoyaltyFee(uint8 fee);\n\n    function initialize(\n        address _owner,\n        string calldata _name,\n        string calldata _symbol,\n        uint256[] calldata tokenIds,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external;\n\n    function initialize(\n        address _owner,\n        string calldata _name,\n        string calldata _symbol,\n        uint256 toTokenId,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external;\n\n    function DOMAIN_SEPARATOR() external view override(IBaseNFT721, IBaseExchange) returns (bytes32);\n\n    function factory() external view override(IBaseNFT721, IBaseExchange) returns (address);\n\n    function royaltyFeeInfo() external view override returns (address recipient, uint8 permil);\n\n    function setRoyaltyFeeRecipient(address _royaltyFeeRecipient) external;\n\n    function setRoyaltyFee(uint8 _royaltyFee) external;\n}\n"
    },
    "contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n///\n/// @dev Interface for the NFT Royalty Standard\n///\ninterface IERC2981 is IERC165 {\n    /// ERC165 bytes to add to interface array - set in parent contract\n    /// implementing this standard\n    ///\n    /// bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a\n    /// bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\n    /// _registerInterface(_INTERFACE_ID_ERC2981);\n\n    /// @notice Called with the sale price to determine how much royalty\n    //          is owed and to whom.\n    /// @param _tokenId - the NFT asset queried for royalty information\n    /// @param _salePrice - the sale price of the NFT asset specified by _tokenId\n    /// @return receiver - address of who should be sent the royalty payment\n    /// @return royaltyAmount - the royalty payment amount for _salePrice\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "contracts/NFT1155V0.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"./interfaces/INFT1155.sol\";\nimport \"./interfaces/IERC2981.sol\";\nimport \"./base/BaseNFT1155.sol\";\nimport \"./base/BaseExchange.sol\";\n\ncontract NFT1155V0 is BaseNFT1155, BaseExchange, IERC2981, INFT1155 {\n    uint8 internal _MAX_ROYALTY_FEE;\n\n    address internal _royaltyFeeRecipient;\n    uint8 internal _royaltyFee; // out of 1000\n\n    function initialize(\n        address _owner,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external override initializer {\n        __BaseNFTExchange_init();\n        initialize(_owner);\n        _MAX_ROYALTY_FEE = ITokenFactory(_factory).MAX_ROYALTY_FEE();\n\n        if (tokenIds.length > 0) {\n            _mintBatch(_owner, tokenIds, amounts, \"\");\n        }\n\n        setRoyaltyFeeRecipient(royaltyFeeRecipient);\n        _royaltyFee = type(uint8).max;\n        if (royaltyFee != 0) setRoyaltyFee(royaltyFee);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        virtual\n        override(ERC1155Initializable, IERC165)\n        returns (bool)\n    {\n        return interfaceId == 0x2a55205a || super.supportsInterface(interfaceId);\n    }\n\n    function DOMAIN_SEPARATOR() public view override(BaseNFT1155, BaseExchange, INFT1155) returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    function factory() public view override(BaseNFT1155, BaseExchange, INFT1155) returns (address) {\n        return _factory;\n    }\n\n    function royaltyFeeInfo() public view override(BaseExchange, INFT1155) returns (address recipient, uint8 permil) {\n        return (_royaltyFeeRecipient, _royaltyFee);\n    }\n\n    function royaltyInfo(uint256, uint256 _salePrice) external view override returns (address, uint256) {\n        return (_royaltyFeeRecipient, (_salePrice * _royaltyFee) / 1000);\n    }\n\n    function _transfer(\n        address,\n        address from,\n        address to,\n        uint256 tokenId,\n        uint256 amount\n    ) internal override {\n        _transfer(from, to, tokenId, amount);\n        emit TransferSingle(msg.sender, from, to, tokenId, amount);\n    }\n\n    function setRoyaltyFeeRecipient(address royaltyFeeRecipient) public override onlyOwner {\n        require(royaltyFeeRecipient != address(0), \"SHOYU: INVALID_FEE_RECIPIENT\");\n\n        _royaltyFeeRecipient = royaltyFeeRecipient;\n\n        emit SetRoyaltyFeeRecipient(royaltyFeeRecipient);\n    }\n\n    function setRoyaltyFee(uint8 royaltyFee) public override onlyOwner {\n        if (_royaltyFee == type(uint8).max) {\n            require(royaltyFee <= _MAX_ROYALTY_FEE, \"SHOYU: INVALID_FEE\");\n        } else {\n            require(royaltyFee < _royaltyFee, \"SHOYU: INVALID_FEE\");\n        }\n\n        _royaltyFee = royaltyFee;\n\n        emit SetRoyaltyFee(royaltyFee);\n    }\n}\n"
    },
    "contracts/interfaces/INFT1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./IBaseNFT1155.sol\";\nimport \"./IBaseExchange.sol\";\n\ninterface INFT1155 is IBaseNFT1155, IBaseExchange {\n    event SetRoyaltyFeeRecipient(address recipient);\n    event SetRoyaltyFee(uint8 fee);\n\n    function initialize(\n        address _owner,\n        uint256[] calldata tokenIds,\n        uint256[] calldata amounts,\n        address royaltyFeeRecipient,\n        uint8 royaltyFee\n    ) external;\n\n    function DOMAIN_SEPARATOR() external view override(IBaseNFT1155, IBaseExchange) returns (bytes32);\n\n    function factory() external view override(IBaseNFT1155, IBaseExchange) returns (address);\n\n    function royaltyFeeInfo() external view override returns (address recipient, uint8 permil);\n\n    function setRoyaltyFeeRecipient(address _royaltyFeeRecipient) external;\n\n    function setRoyaltyFee(uint8 _royaltyFee) external;\n}\n"
    },
    "contracts/base/BaseNFT1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\nimport \"../interfaces/IBaseNFT1155.sol\";\nimport \"../interfaces/IERC1271.sol\";\nimport \"../interfaces/ITokenFactory.sol\";\nimport \"../base/ERC1155Initializable.sol\";\nimport \"../base/OwnableInitializable.sol\";\n\nabstract contract BaseNFT1155 is ERC1155Initializable, OwnableInitializable, IBaseNFT1155 {\n    using Strings for uint256;\n\n    // keccak256(\"Permit(address owner,address spender,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant override PERMIT_TYPEHASH =\n        0xdaab21af31ece73a508939fedd476a5ee5129a5ed4bb091f3236ffb45394df62;\n    bytes32 internal _DOMAIN_SEPARATOR;\n    uint8 internal MAX_ROYALTY_FEE;\n\n    address internal _factory;\n    string internal _baseURI;\n    mapping(uint256 => string) internal _uris;\n\n    mapping(address => uint256) public override nonces;\n\n    function initialize(address _owner) public override initializer {\n        __ERC1155_init(\"\");\n        __Ownable_init(_owner);\n        _factory = msg.sender;\n\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        _DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(Strings.toHexString(uint160(address(this))))),\n                0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6, // keccak256(bytes(\"1\"))\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function DOMAIN_SEPARATOR() public view virtual override returns (bytes32) {\n        return _DOMAIN_SEPARATOR;\n    }\n\n    function factory() public view virtual override returns (address) {\n        return _factory;\n    }\n\n    function uri(uint256 id)\n        public\n        view\n        virtual\n        override(ERC1155Initializable, IERC1155MetadataURI)\n        returns (string memory)\n    {\n        string memory _uri = _uris[id];\n        if (bytes(_uri).length > 0) {\n            return _uri;\n        } else {\n            string memory baseURI = _baseURI;\n            if (bytes(baseURI).length > 0) {\n                return string(abi.encodePacked(baseURI, \"{id}.json\"));\n            } else {\n                baseURI = ITokenFactory(_factory).baseURI1155();\n                string memory addy = Strings.toHexString(uint160(address(this)), 20);\n                return string(abi.encodePacked(baseURI, addy, \"/{id}.json\"));\n            }\n        }\n    }\n\n    function setURI(uint256 id, string memory newURI) external override onlyOwner {\n        _uris[id] = newURI;\n    }\n\n    function setBaseURI(string memory baseURI) external override onlyOwner {\n        _baseURI = baseURI;\n    }\n\n    function mint(\n        address to,\n        uint256 tokenId,\n        uint256 amount,\n        bytes memory data\n    ) external override {\n        require(_factory == msg.sender || owner() == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _mint(to, tokenId, amount, data);\n    }\n\n    function mintBatch(\n        address to,\n        uint256[] memory tokenIds,\n        uint256[] memory amounts,\n        bytes memory data\n    ) external override {\n        require(owner() == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _mintBatch(to, tokenIds, amounts, data);\n    }\n\n    function burn(\n        uint256 tokenId,\n        uint256 amount,\n        uint256 label,\n        bytes32 data\n    ) external override {\n        _burn(msg.sender, tokenId, amount);\n\n        emit Burn(tokenId, amount, label, data);\n    }\n\n    function burnBatch(uint256[] calldata tokenIds, uint256[] calldata amounts) external override {\n        _burnBatch(msg.sender, tokenIds, amounts);\n    }\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external override {\n        require(block.timestamp <= deadline);\n\n        bytes32 digest =\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    _DOMAIN_SEPARATOR,\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, nonces[owner], deadline))\n                )\n            );\n        nonces[owner] += 1;\n\n        if (Address.isContract(owner)) {\n            require(\n                IERC1271(owner).isValidSignature(digest, abi.encodePacked(r, s, v)) == 0x1626ba7e,\n                \"SHOYU: UNAUTHORIZED\"\n            );\n        } else {\n            address recoveredAddress = ecrecover(digest, v, r, s);\n            require(recoveredAddress != address(0), \"SHOYU: INVALID_SIGNATURE\");\n            require(recoveredAddress == owner, \"SHOYU: UNAUTHORIZED\");\n        }\n\n        _setApprovalForAll(owner, spender, true);\n    }\n}\n"
    },
    "contracts/base/ERC20SnapshotInitializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/utils/Arrays.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\nimport \"../interfaces/IERC20Snapshot.sol\";\nimport \"./ERC20Initializable.sol\";\n\n/**\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\n * total supply at the time are recorded for later access.\n *\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\n * In naive implementations it's possible to perform a \"double spend\" attack by reusing the same balance from different\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\n * used to create an efficient ERC20 forking mechanism.\n *\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\n * and the account address.\n *\n * ==== Gas Costs\n *\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\n *\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\n * transfers will have normal cost until the next snapshot, and so on.\n */\nabstract contract ERC20SnapshotInitializable is ERC20Initializable, IERC20Snapshot {\n    function __ERC20Snapshot_init() internal initializer {\n        __ERC20Snapshot_init_unchained();\n    }\n\n    function __ERC20Snapshot_init_unchained() internal initializer {}\n\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\n    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\n\n    using Arrays for uint256[];\n    using Counters for Counters.Counter;\n\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\n    // Snapshot struct, but that would impede usage of functions that work on an array.\n    struct Snapshots {\n        uint256[] ids;\n        uint256[] values;\n    }\n\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\n    Snapshots private _totalSupplySnapshots;\n\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\n    Counters.Counter private _currentSnapshotId;\n\n    /**\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\n     */\n    event Snapshot(uint256 id);\n\n    /**\n     * @dev Creates a new snapshot and returns its snapshot id.\n     *\n     * Emits a {Snapshot} event that contains the same id.\n     *\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\n     *\n     * [WARNING]\n     * ====\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\n     * you must consider that it can potentially be used by attackers in two ways.\n     *\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\n     * section above.\n     *\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\n     * ====\n     */\n    function _snapshot() internal virtual returns (uint256) {\n        _currentSnapshotId.increment();\n\n        uint256 currentId = _currentSnapshotId.current();\n        emit Snapshot(currentId);\n        return currentId;\n    }\n\n    /**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual override returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\n\n        return snapshotted ? value : balanceOf(account);\n    }\n\n    /**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n    function totalSupplyAt(uint256 snapshotId) public view virtual override returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\n\n        return snapshotted ? value : totalSupply();\n    }\n\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from == address(0)) {\n            // mint\n            _updateAccountSnapshot(to);\n            _updateTotalSupplySnapshot();\n        } else if (to == address(0)) {\n            // burn\n            _updateAccountSnapshot(from);\n            _updateTotalSupplySnapshot();\n        } else {\n            // transfer\n            _updateAccountSnapshot(from);\n            _updateAccountSnapshot(to);\n        }\n    }\n\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\n        require(snapshotId > 0, \"SHOYU: INVALID_SNAPSHOT_ID\");\n        // solhint-disable-next-line max-line-length\n        require(snapshotId <= _currentSnapshotId.current(), \"SHOYU: NON_EXISTENT\");\n\n        // When a valid snapshot is queried, there are three possibilities:\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\n        //  to this id is the current one.\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\n        //  requested id, and its value is the one to return.\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\n        //  larger than the requested one.\n        //\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\n        // exactly this.\n\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\n\n        if (index == snapshots.ids.length) {\n            return (false, 0);\n        } else {\n            return (true, snapshots.values[index]);\n        }\n    }\n\n    function _updateAccountSnapshot(address account) private {\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\n    }\n\n    function _updateTotalSupplySnapshot() private {\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\n    }\n\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\n        uint256 currentId = _currentSnapshotId.current();\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\n            snapshots.ids.push(currentId);\n            snapshots.values.push(currentValue);\n        }\n    }\n\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\n        if (ids.length == 0) {\n            return 0;\n        } else {\n            return ids[ids.length - 1];\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Arrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n   /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (array[mid] > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && array[low - 1] == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IERC20Snapshot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\ninterface IERC20Snapshot is IERC20, IERC20Metadata {\n    function balanceOfAt(address account, uint256 snapshotId) external view returns (uint256);\n\n    function totalSupplyAt(uint256 snapshotId) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow, so we distribute\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\n    }\n}\n"
    },
    "contracts/ERC721GovernanceToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\nimport \"./interfaces/IERC721GovernanceToken.sol\";\nimport \"./interfaces/ITokenFactory.sol\";\nimport \"./interfaces/IBaseExchange.sol\";\nimport \"./interfaces/IOrderBook.sol\";\nimport \"./base/ERC20SnapshotInitializable.sol\";\nimport \"./libraries/Orders.sol\";\n\ncontract ERC721GovernanceToken is ERC20SnapshotInitializable, IERC721GovernanceToken {\n    using SafeERC20 for IERC20;\n    using Orders for Orders.Ask;\n\n    struct SellProposal {\n        bool executed;\n        address strategy;\n        address currency;\n        uint256 deadline;\n        bytes params;\n        uint256 expiration;\n        uint256 snapshotId;\n    }\n\n    uint256 internal constant TOTAL_SUPPLY = 100e18;\n\n    address public override factory;\n    address public override orderBook;\n    address public override nft;\n    uint256 public override tokenId;\n    uint8 public override minimumQuorum; // out of 100\n\n    SellProposal[] public override proposals;\n    mapping(uint256 => uint256) public override totalPowerOf;\n    mapping(uint256 => mapping(address => uint256)) public override powerOf;\n\n    mapping(uint256 => bool) internal _sold;\n\n    function initialize(\n        address _factory,\n        address _orderBook,\n        address _nft,\n        uint256 _tokenId,\n        uint8 _minimumQuorum\n    ) external override initializer {\n        __ERC20_init(\"Shoyu NFT-721 Governance\", \"G-ERC721\");\n        require(_minimumQuorum <= 100, \"SHOYU: INVALID_MINIMUM_QUORUM\");\n\n        factory = _factory;\n        orderBook = _orderBook;\n        nft = _nft;\n        tokenId = _tokenId;\n        minimumQuorum = _minimumQuorum;\n    }\n\n    function proposalsLength() external view override returns (uint256) {\n        return proposals.length;\n    }\n\n    function mint(address account, uint256 amount) external override {\n        require(nft == msg.sender, \"SHOYU: FORBIDDEN\");\n\n        _mint(account, amount);\n    }\n\n    function claimPayout(uint256 id) external override {\n        SellProposal storage proposal = proposals[id];\n\n        if (!_sold[id]) {\n            address exchange = ITokenFactory(factory).isNFT721(nft) ? nft : ITokenFactory(factory).erc721Exchange();\n            bytes32 hash = _hashOrder(proposal);\n            require(IBaseExchange(exchange).amountFilled(hash) > 0, \"SHOYU: NOT_SOLD\");\n\n            _sold[id] = true;\n        }\n\n        uint256 share = balanceOf(msg.sender);\n        require(share > 0, \"SHOYU: INSUFFICIENT_BALANCE\");\n        _burn(msg.sender, share);\n\n        address _currency = proposal.currency;\n        uint256 payout = IERC20(_currency).balanceOf(address(this));\n        uint256 amount = (payout * share) / totalSupply();\n        IERC20(_currency).safeTransfer(msg.sender, amount);\n    }\n\n    function _hashOrder(SellProposal storage proposal) internal view returns (bytes32) {\n        Orders.Ask memory ask =\n            Orders.Ask(\n                address(this),\n                nft,\n                tokenId,\n                1,\n                proposal.strategy,\n                proposal.currency,\n                address(0),\n                proposal.deadline,\n                proposal.params,\n                uint8(0),\n                \"\",\n                \"\"\n            );\n        return ask.hash();\n    }\n\n    function submitSellProposal(\n        address strategy,\n        address currency,\n        uint256 deadline,\n        bytes calldata params,\n        uint256 expiration\n    ) external override {\n        require(msg.sender == tx.origin, \"SHOYU: CONTRACT_CALL_FORBIDDEN\");\n        require(block.number < expiration, \"SHOYU: EXPIRED\");\n\n        uint256 power = balanceOf(msg.sender);\n        require(power > 0, \"SHOYU: INSUFFICIENT_POWER\");\n\n        uint256 id = proposals.length;\n        uint256 snapshotId = _snapshot();\n\n        proposals.push(SellProposal(false, strategy, currency, deadline, params, expiration, snapshotId));\n        totalPowerOf[id] = power;\n        powerOf[id][msg.sender] = power;\n\n        emit SubmitSellProposal(id, snapshotId, msg.sender, power);\n    }\n\n    function confirmSellProposal(uint256 id) external override {\n        SellProposal storage proposal = proposals[id];\n        require(!proposal.executed, \"SHOYU: EXECUTED\");\n        require(block.number <= proposal.expiration, \"SHOYU: EXPIRED\");\n        require(totalPowerOf[id] > 0, \"SHOYU: NOT_SUBMITTED\");\n        require(powerOf[id][msg.sender] == 0, \"SHOYU: CONFIRMED\");\n\n        uint256 power = balanceOfAt(msg.sender, proposal.snapshotId);\n        require(power > 0, \"SHOYU: INSUFFICIENT_POWER\");\n\n        totalPowerOf[id] += power;\n        powerOf[id][msg.sender] = power;\n\n        emit ConfirmSellProposal(id, msg.sender, power);\n\n        if (totalPowerOf[id] > _minPower()) {\n            _executeSellProposal(proposal);\n\n            emit ExecuteSellProposal(id);\n        }\n    }\n\n    function revokeSellProposal(uint256 id) external override {\n        SellProposal storage proposal = proposals[id];\n        require(!proposal.executed, \"SHOYU: EXECUTED\");\n        require(block.number <= proposal.expiration, \"SHOYU: EXPIRED\");\n\n        uint256 power = powerOf[id][msg.sender];\n        require(power > 0, \"SHOYU: NOT_CONFIRMED\");\n\n        totalPowerOf[id] -= power;\n        powerOf[id][msg.sender] = 0;\n\n        emit RevokeSellProposal(id, msg.sender, power);\n    }\n\n    function executeSellProposal(uint256 id) external override {\n        SellProposal storage proposal = proposals[id];\n        require(!proposal.executed, \"SHOYU: EXECUTED\");\n        require(block.number <= proposal.expiration, \"SHOYU: EXPIRED\");\n        require(totalPowerOf[id] > _minPower(), \"SHOYU: NOT_SUBMITTED\");\n\n        _executeSellProposal(proposal);\n\n        emit ExecuteSellProposal(id);\n    }\n\n    function _minPower() internal view returns (uint256) {\n        return (TOTAL_SUPPLY * minimumQuorum) / 100;\n    }\n\n    function _executeSellProposal(SellProposal storage proposal) internal {\n        try\n            IOrderBook(orderBook).submitOrder(\n                nft,\n                tokenId,\n                1,\n                proposal.strategy,\n                proposal.currency,\n                address(0),\n                proposal.deadline,\n                proposal.params\n            )\n        returns (bytes32) {\n            proposal.executed = true;\n        } catch {}\n    }\n}\n"
    },
    "contracts/interfaces/IERC721GovernanceToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./IERC20Snapshot.sol\";\n\ninterface IERC721GovernanceToken is IERC20Snapshot {\n    event SubmitSellProposal(uint256 id, uint256 snapshotId, address indexed from, uint256 power);\n    event ConfirmSellProposal(uint256 id, address indexed from, uint256 power);\n    event RevokeSellProposal(uint256 id, address indexed from, uint256 power);\n    event ExecuteSellProposal(uint256 id);\n\n    function initialize(\n        address _factory,\n        address _orderBook,\n        address _nft,\n        uint256 _tokenId,\n        uint8 _minimumQuorum\n    ) external;\n\n    function factory() external view returns (address);\n\n    function orderBook() external view returns (address);\n\n    function nft() external view returns (address);\n\n    function tokenId() external view returns (uint256);\n\n    function minimumQuorum() external view returns (uint8);\n\n    function proposals(uint256 index)\n        external\n        view\n        returns (\n            bool executed,\n            address strategy,\n            address currency,\n            uint256 deadline,\n            bytes memory params,\n            uint256 expiration,\n            uint256 snapshotId\n        );\n\n    function proposalsLength() external view returns (uint256);\n\n    function totalPowerOf(uint256 id) external view returns (uint256);\n\n    function powerOf(uint256 id, address account) external view returns (uint256);\n\n    function mint(address account, uint256 amount) external;\n\n    function claimPayout(uint256 id) external;\n\n    function submitSellProposal(\n        address strategy,\n        address currency,\n        uint256 deadline,\n        bytes calldata params,\n        uint256 expiration\n    ) external;\n\n    function confirmSellProposal(uint256 id) external;\n\n    function revokeSellProposal(uint256 id) external;\n\n    function executeSellProposal(uint256 id) external;\n}\n"
    },
    "contracts/interfaces/IOrderBook.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface IOrderBook {\n    event SubmitOrder(bytes32 indexed hash);\n\n    function orders(bytes32 hash)\n        external\n        view\n        returns (\n            address signer,\n            address nft,\n            uint256 tokenId,\n            uint256 amount,\n            address strategy,\n            address currency,\n            address recipient,\n            uint256 deadline,\n            bytes memory params,\n            uint8 v,\n            bytes32 r,\n            bytes32 s\n        );\n\n    function submitOrder(\n        address nft,\n        uint256 tokenId,\n        uint256 amount,\n        address strategy,\n        address currency,\n        address recipient,\n        uint256 deadline,\n        bytes memory params\n    ) external returns (bytes32 hash);\n}\n"
    },
    "contracts/ERC721Liquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\n\nimport \"./interfaces/IERC721Liquidator.sol\";\nimport \"./base/ProxyFactory.sol\";\nimport \"./ERC721GovernanceToken.sol\";\n\ncontract ERC721Liquidator is ProxyFactory, IERC721Liquidator {\n    address public immutable factory;\n    address public immutable orderBook;\n    address internal immutable _target;\n\n    constructor(address _factory, address _orderBook) {\n        factory = _factory;\n        orderBook = _orderBook;\n\n        ERC721GovernanceToken token = new ERC721GovernanceToken();\n        token.initialize(address(0), address(0), address(0), 0, 0);\n        _target = address(token);\n    }\n\n    function liquidate(\n        address nft,\n        uint256 tokenId,\n        uint8 minimumQuorum\n    ) external override returns (address proxy) {\n        bytes memory initData =\n            abi.encodeWithSignature(\n                \"initialize(address,address,address,uint256,uint8)\",\n                factory,\n                orderBook,\n                nft,\n                tokenId,\n                minimumQuorum\n            );\n        proxy = _createProxy(_target, initData);\n\n        IERC721(nft).safeTransferFrom(msg.sender, proxy, tokenId);\n\n        emit Liquidate(proxy, nft, tokenId, minimumQuorum);\n    }\n}\n"
    },
    "contracts/interfaces/IERC721Liquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface IERC721Liquidator {\n    event Liquidate(address indexed proxy, address indexed nft, uint256 indexed tokenId, uint8 minimumQuorum);\n\n    function liquidate(\n        address nft,\n        uint256 tokenId,\n        uint8 minimumQuorum\n    ) external returns (address proxy);\n}\n"
    },
    "contracts/OrderBook.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"./interfaces/IOrderBook.sol\";\nimport \"./libraries/Orders.sol\";\n\ncontract OrderBook is IOrderBook {\n    using Orders for Orders.Ask;\n\n    mapping(bytes32 => Orders.Ask) public override orders;\n\n    function submitOrder(\n        address nft,\n        uint256 tokenId,\n        uint256 amount,\n        address strategy,\n        address currency,\n        address recipient,\n        uint256 deadline,\n        bytes memory params\n    ) external override returns (bytes32 hash) {\n        Orders.Ask memory order =\n            Orders.Ask(\n                msg.sender,\n                nft,\n                tokenId,\n                amount,\n                strategy,\n                currency,\n                recipient,\n                deadline,\n                params,\n                0,\n                bytes32(0),\n                bytes32(0)\n            );\n        hash = order.hash();\n        orders[hash] = order;\n    }\n}\n"
    },
    "contracts/strategies/FixedPriceSale.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"../interfaces/IStrategy.sol\";\n\ncontract FixedPriceSale is IStrategy {\n    function canExecute(\n        uint256 deadline,\n        bytes memory params,\n        address,\n        uint256 bidPrice\n    ) external view override returns (bool) {\n        uint256 price = abi.decode(params, (uint256));\n        require(price > 0, \"SHOYU: INVALID_PRICE\");\n        return block.number <= deadline && bidPrice == price;\n    }\n\n    function canBid(\n        uint256,\n        bytes memory,\n        address,\n        uint256,\n        uint256,\n        uint256\n    ) external pure override returns (bool) {\n        return false;\n    }\n}\n"
    },
    "contracts/strategies/EnglishAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"../interfaces/IStrategy.sol\";\n\ncontract EnglishAuction is IStrategy {\n    function canExecute(\n        uint256 deadline,\n        bytes memory,\n        address,\n        uint256\n    ) external view override returns (bool) {\n        return deadline < block.number;\n    }\n\n    function canBid(\n        uint256 deadline,\n        bytes memory params,\n        address,\n        uint256 bidPrice,\n        uint256 bestBidPrice,\n        uint256\n    ) external view override returns (bool) {\n        uint256 startPrice = abi.decode(params, (uint256));\n        require(startPrice > 0, \"SHOYU: INVALID_START_PRICE\");\n\n        return block.number <= deadline && bidPrice >= startPrice && bidPrice > bestBidPrice;\n    }\n}\n"
    },
    "contracts/strategies/DutchAuction.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"../interfaces/IStrategy.sol\";\n\ncontract DutchAuction is IStrategy {\n    function canExecute(\n        uint256 deadline,\n        bytes memory params,\n        address,\n        uint256 bidPrice\n    ) external view override returns (bool) {\n        (uint256 startPrice, uint256 endPrice, uint256 startBlock) = abi.decode(params, (uint256, uint256, uint256));\n        require(startPrice > endPrice, \"SHOYU: INVALID_PRICE_RANGE\");\n        require(startBlock < deadline, \"SHOYU: INVALID_START_BLOCK\");\n\n        uint256 tickPerBlock = (startPrice - endPrice) / (deadline - startBlock);\n        uint256 currentPrice = startPrice - ((block.number - startBlock) * tickPerBlock);\n\n        return block.number <= deadline && bidPrice >= currentPrice;\n    }\n\n    function canBid(\n        uint256,\n        bytes memory,\n        address,\n        uint256,\n        uint256,\n        uint256\n    ) external pure override returns (bool) {\n        return false;\n    }\n}\n"
    },
    "contracts/strategies/DesignatedSale.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"../interfaces/IStrategy.sol\";\n\ncontract DesignatedSale is IStrategy {\n    function canExecute(\n        uint256,\n        bytes memory params,\n        address bidder,\n        uint256 bidPrice\n    ) external pure override returns (bool) {\n        (uint256 minPrice, address designee) = abi.decode(params, (uint256, address));\n        require(designee != address(0), \"SHOYU: INVALID_DESIGNEE\");\n\n        return minPrice <= bidPrice && bidder == designee;\n    }\n\n    function canBid(\n        uint256,\n        bytes memory,\n        address,\n        uint256,\n        uint256,\n        uint256\n    ) external pure override returns (bool) {\n        return false;\n    }\n}\n"
    },
    "contracts/PaymentSplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity =0.8.3;\n\nimport \"./interfaces/IPaymentSplitter.sol\";\nimport \"./libraries/TokenHelper.sol\";\n\n// Reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/finance/PaymentSplitter.sol\ncontract PaymentSplitter is IPaymentSplitter {\n    using TokenHelper for address;\n\n    string public override title;\n\n    /**\n     * @dev Getter for the total shares held by payees.\n     */\n    uint256 public override totalShares;\n    /**\n     * @dev Getter for the total amount of token already released.\n     */\n    mapping(address => uint256) public override totalReleased;\n\n    /**\n     * @dev Getter for the amount of shares held by an account.\n     */\n    mapping(address => uint256) public override shares;\n    /**\n     * @dev Getter for the amount of token already released to a payee.\n     */\n    mapping(address => mapping(address => uint256)) public override released;\n    /**\n     * @dev Getter for the address of the payee number `index`.\n     */\n    address[] public override payees;\n\n    /**\n     * @dev Creates an instance of `PaymentSplitter` where each account in `payees` is assigned the number of shares at\n     * the matching position in the `shares` array.\n     *\n     * All addresses in `payees` must be non-zero. Both arrays must have the same non-zero length, and there must be no\n     * duplicates in `payees`.\n     */\n    constructor(\n        string memory _title,\n        address[] memory _payees,\n        uint256[] memory _shares\n    ) payable {\n        require(_payees.length == _shares.length, \"PaymentSplitter: payees and shares length mismatch\");\n        require(_payees.length > 0, \"PaymentSplitter: no payees\");\n\n        title = _title;\n\n        for (uint256 i = 0; i < _payees.length; i++) {\n            _addPayee(_payees[i], _shares[i]);\n        }\n    }\n\n    /**\n     * @dev Triggers a transfer to `account` of the amount of token they are owed, according to their percentage of the\n     * total shares and their previous withdrawals.\n     */\n    function release(address token, address account) external virtual override {\n        require(shares[account] > 0, \"SHOYU: FORBIDDEN\");\n\n        uint256 totalReceived = token.balanceOf(address(this)) + totalReleased[token];\n        uint256 payment = (totalReceived * shares[account]) / totalShares - released[token][account];\n\n        require(payment != 0, \"SHOYU: NO_PAYMENT\");\n\n        released[token][account] += payment;\n        totalReleased[token] += payment;\n\n        token.safeTransfer(account, payment);\n        emit PaymentReleased(token, account, payment);\n    }\n\n    /**\n     * @dev Add a new payee to the contract.\n     * @param account The address of the payee to add.\n     * @param _shares The number of shares owned by the payee.\n     */\n    function _addPayee(address account, uint256 _shares) private {\n        require(account != address(0), \"SHOYU: INVALID_ADDRESS\");\n        require(_shares > 0, \"SHOYU: INVALID_SHARES\");\n        require(shares[account] == 0, \"SHOYU: ALREADY_ADDED\");\n\n        payees.push(account);\n        shares[account] = _shares;\n        totalShares = totalShares + _shares;\n        emit PayeeAdded(account, _shares);\n    }\n}\n"
    },
    "contracts/interfaces/IPaymentSplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface IPaymentSplitter {\n    event PayeeAdded(address account, uint256 shares);\n    event PaymentReleased(address token, address to, uint256 amount);\n\n    function title() external view returns (string memory);\n\n    function totalShares() external view returns (uint256);\n\n    function totalReleased(address account) external view returns (uint256);\n\n    function shares(address account) external view returns (uint256);\n\n    function released(address token, address account) external view returns (uint256);\n\n    function payees(uint256 index) external view returns (address);\n\n    function release(address token, address account) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}
